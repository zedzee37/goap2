class_name Planner
extends Node


@onready var goal_container: GoalContainer = $GoalContainer
@onready var action_container: ActionContainer = $ActionContainer


# TODO: replace this with an A* search
func find_lowest_cost_path(goal: Goal, current_state: State) -> Array[Action]:
	var actions: Array[Action] = []

	if goal.is_fulfilled(current_state):
		return actions
	
	var queue := PriorityQueue.new(func(a, b): return a.f_cost() < b.f_cost())
	for action in action_container.actions:
		if not action.is_available(current_state):
			continue

		var node := ActionNode.new(
			0, 
			goal.projected_cost(current_state), 
			action, 
			current_state,
			action.resultant(current_state)
		)

		queue.insert(node)
	
	var path = null
	while queue.size() > 0:
		var current_node = queue.pop()
		print()
		print(current_node.action)
		print("state: " +  str(current_node.state.trees))
		print("cost: " + str(current_node.f_cost()))
		print()

		for action in action_container.actions:
			if not action.is_available(current_node.state):
				continue

			var projected_state := action.resultant(current_node.state)

			var node := ActionNode.new(
				current_node.g_cost,
				goal.projected_cost(projected_state),
				action,
				current_node.state,
				projected_state,
				current_node
			)

			if goal.is_fulfilled(projected_state):
				path = node
				continue

			queue.insert(node)

		if path != null:
			break
	
	while path.parent != null:
		actions.append(path.action)
		path = path.parent
	
	return actions


class ActionNode:
	var h_cost: float
	var g_cost: float
	var parent: ActionNode
	var action: Action
	var state: State

	func _init(_g_cost: float, _h_cost: float, _action: Action, _prev_state: State, _projected_state: State, _parent: ActionNode = null) -> void:
		self.g_cost = _g_cost + _action.cost(_prev_state)
		self.h_cost = _h_cost
		self.parent = _parent
		self.action = _action
		self.state = _projected_state
	
	func f_cost() -> float:
		return g_cost + h_cost
